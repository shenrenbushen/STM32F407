#include "s_critical.h"

static INT8U critical_cnt = 0;
static INT32U ea_state = 1;

/*--------------------------------------------
note:进入临界区（返回临界区层数）
--------------------------------------------*/
INT8U enter_critical(void)
{
	if(0 == critical_cnt)
	{
		ea_state = __get_PRIMASK();
	}
	__set_PRIMASK(1);
	critical_cnt++;
	return critical_cnt;
}


/*--------------------------------------------
note:退出临界区（返回临界区层数）
--------------------------------------------*/
INT8U exit_critical(void)
{
	if(critical_cnt>0)
	{
		critical_cnt--;
	}
	if(0 == critical_cnt)
	{
		__set_PRIMASK(ea_state);
	}
	return critical_cnt;
}


/*--------------------------------------------
note:查询临界区层数（返回临界区层数）
--------------------------------------------*/
INT8U inquire_critical(void)
{
	return critical_cnt;
}


//(1)首先，来说明一下为什么要使用临界区，什么时候需要临界区？
//比如有个int类型的变量a，占4个Byte，单片机真正去给a赋值的时候一条汇编语句是实现不了的，如果说在main函数中给a赋值到一半的时候，中断中突然也是去改写a这个变量，
//那么在中断中a被改了一遍后，出了中断a接着改另一半，这样做把a改成不是我们想要的值了，所以加入临界区机制，防止这种情况的发生。


//(2)什么时候需要临界区？
//a、如果仅仅只是在中断中去读这个变量，那么没有任何问题，不需要使用临界区机制，如果既在中断中写，也在main函数中写，那么main函数中写变量的时候需要加临界区了。
//b、如果是在多个中断中同时使用这个变量，而且中断能抢占的时候，低优先级也要使用临界区机制。

//(3)critical_cnt的作用是判断当前进入临界区的层数，有的时候在进入了临界区后，又使用了进入临界区，如果我们不判断是第几层临界区，直接在退出临界区的时候
//打开中断，那么其实还在临界区中但是中断已经被打开

//EA = 0;			//进入临界区1
//func();
//EA = 0;			//进入临界区2
//func();
//EA = 1;			//退出临界区2，这时候还在临界区中，但是中断已经被打开，所以这里需要加上判断临界区层数来防止提早打开临界区
//func();
//EA = 1;			//退出临界区1

//(4)进临界区或者出临界区一定要成双成对出现，但是有时候退出临界区函数要多一些，比如说下面的函数

//ITF_enter_critical();				
//if(flag == 1)
//{
//	ITF_exit_critical();
//	return;
//}
//ITF_exit_critical();















